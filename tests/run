#!/usr/bin/env bash

# navigate to where this script is located
pushd $(dirname "$(readlink -f "$0")") >/dev/null
source ./utils

setup # sets the current directory to this script's location
trap cleanup EXIT
HERE=$PWD
TMP_DIR=/tmp/gitnu
rm -rf $TMP_DIR && mkdir -p $TMP_DIR/failed

# parse arguments
for i in "$@"; do
  [[ "$i" =~ [0-9]+ ]] && [ -z $ONE_TEST ] && printf -v ONE_TEST "%02d" $i
done

N=0 # current id
let PASSES=0
let TOTAL=0

# $1 : aboslute path to ./cases/*.sh
test() {
  [ ! -f $1 ] && echo "No such test file" && return
  local recfile=$TMP_DIR/$N.rec
  local expfile=$TMP_DIR/$N.exp
  local difffile=$TMP_DIR/failed/$N.diff
  save() {
    eval "$@" >$recfile
  }
  set_sha() {
    SHA=$(eval "$@")
  }
  mkdir -p $HERE/log
  GITNU=$GITNU source $1 &>$HERE/log/$N.full
  local EX_START=0
  # generate expected file from comments in test file
  while read -r line; do
    line=${line:2}
    line="${line/\[:SHA:\]/$SHA}"
    if [ $EX_START = 1 ]; then
      echo "$line" >>$expfile
    fi
    [[ $line = *"------------------------------"* ]] && EX_START=1
  done <$1
  local title=$(get_test_title $1) && local testfile=${1##$HERE/}
  local rc=0 # return code
  [ ! -f $recfile ] && not_found $testfile $N.rec && rc=1
  [ ! -f $expfile ] && not_found $testfile $N.exp && rc=1

  # either received/expected not found
  [ $rc = 1 ] && return 1

  # gather stats and diff
  diff -y -W 70 $recfile $expfile >$difffile
  rc=$?
  if [[ $rc == 0 ]]; then
    pass $testfile "$title"
    rm -f $difffile
  else
    fail $testfile "$title"
  fi
  return $rc
}

# $1 : absolute path to test file
wrap_test() {
  let TOTAL++
  assert $PWD $HERE && N=$(get_test_id $1)
  mkdir -p $TMP_DIR/$N
  cd $TMP_DIR/$N && test "$1" &
  pids+=("$!")
}

main() {
  # build
  cargo build --quiet || exit 1

  # ensure correct binary is used
  if ! command -v __gitnu__ >/dev/null; then
    echo 'gitnu not found. Aborting.' && exit 1
  fi

  pids=()

  # run test cases
  if [ $ONE_TEST ]; then
    wrap_test $HERE/cases/$ONE_TEST.sh # run one test
    wait $pid
    echo '[ final output ] ───────────────'
    cat $TMP_DIR/$ONE_TEST.rec
    echo '[ all output ] ─────────────────'
    cat $HERE/log/$ONE_TEST.full
    echo '────────────────────────────────'
  else
    for t in $HERE/cases/*; do # run all tests
      wrap_test $t
    done
  fi

  # wait for all tests to finish
  [ -z $ONE_TEST ] && for pid in ${pids[@]}; do
    wait $pid
    [[ $? == 0 ]] && let PASSES++
  done

  # summarize
  printf "\n $PASSES/$TOTAL tests passed\n"
  [ $PASSES = $TOTAL ] && [ $TOTAL -gt 0 ]
}

main
