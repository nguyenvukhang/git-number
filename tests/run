#!/usr/bin/env bash

# navigate to where this script is located
pushd $(dirname "$(readlink -f "$0")") >/dev/null
source ./utils
setup # sets the current directory to this script's location
trap cleanup EXIT
HERE=$PWD

# parse arguments
for i in "$@"; do
  [[ "$i" =~ [0-9]+ ]] && [ -z $ONE_TEST ] && printf -v ONE_TEST "%02d" $i
done

N=0 # current id
let PASSES=0
let TOTAL=0

# $1 : aboslute path to ./cases/*.sh
test() {
  [ ! -f $1 ] && echo "No such test file" && return
  source $1 &>/dev/null
  local title=$(get_test_title $1) && local file=${1##$HERE/}
  local rec=$HERE/received/$N.txt && local exp=$HERE/expected/$N.txt
  local rc=0 # return code
  [ ! -f $rec ] && not_found $file received/$N.txt && rc=1
  [ ! -f $exp ] && not_found $file expected/$N.txt && rc=1

  # either received/expected not found
  [ $rc = 1 ] && return 1

  # gather stats and diff
  local difffile=$HERE/failed/$N.diff
  diff -y -W 70 $rec $exp >$difffile
  rc=$?
  if [[ $rc == 0 ]]; then
    pass $file "$title"
    rm -f $difffile
  else
    fail $file "$title"
  fi
  return $rc
}

# $1 : absolute path to test file
wrap_test() {
  let TOTAL++
  assert $PWD $HERE && N=$(get_test_id $1)
  tmp_dir=$HERE/tmp/$N && mkdir -p $tmp_dir
  cd $tmp_dir && test "$1" &
  pids+=("$!")
}

main() {
  # build
  cargo build --quiet || exit 1

  # ensure correct binary is used
  if ! command -v gitnu >/dev/null; then
    echo 'gitnu not found. Aborting.' && exit 1
  fi

  pids=()

  # run test cases
  if [ $ONE_TEST ]; then
    wrap_test $HERE/cases/$ONE_TEST.sh # run one test
    wait $pid
    echo '────────────────────────'
    cat $HERE/received/$ONE_TEST.txt
    echo '────────────────────────'
  else
    for t in $HERE/cases/*; do # run all tests
      wrap_test $t
    done
  fi

  # wait for all tests to finish
  [ -z $ONE_TEST ] && for pid in ${pids[@]}; do
    wait $pid
    [[ $? == 0 ]] && let PASSES++
  done

  # summarize
  printf "\n $PASSES/$TOTAL tests passed\n"
  [ $PASSES = $TOTAL ] && [ $TOTAL -gt 0 ]
}

log_results() {
  assert $PWD $HERE
  local file=$HERE/log/$(date +'%Y-%m-%d-%H:%M:%S').txt
  local ENR="echo '% < received | expected >'"
  rm -f $file
  ls failed | xargs -I % sh -c \
    "$ENR && cat failed/% && printf '\n-----\n\n'" \
    >$file >latest.log
  printf "\n ${HERE/$HOME/~}/latest.log\n\n"
}

main
ec=$?
[[ $ec = 1 ]] && log_results
exit $ec
