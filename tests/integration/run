#!/usr/bin/env bash

# navigate to where this script is located
pushd $(dirname "$(readlink -f "$0")") >/dev/null
source ./utils
setup # sets the current directory to this script's location
trap cleanup EXIT
HERE=$PWD

# parse arguments
for i in "$@"; do
  [ $i = '-v' ] && VERBOSE=true
  [ $i = '-s' ] && SILENT=true
  [[ "$i" =~ [0-9]+ ]] && [ -z $ONE_TEST ] && printf -v ONE_TEST "%02d" $i
done

N=0 # current id
let PASSES=0
let TOTAL=0

# for use in ./tests/*.sh
# $1 is number of files to mock up
init() {
  _git init
  let local i=1
  while [ $i -le $1 ]; do
    touch "file_$i" && let i++
  done
}

# for use in ./tests/*.sh
# evaluates command and sends to $REC_DIR
log() {
  eval "$@" >$REC_DIR/$N.txt
}

# $1 : aboslute path to ./tests/*.sh
test() {
  [ ! -f $1 ] && echo "No such test file" && return
  source $1 &>/dev/null
  local title=$(get_test_title $1) && local file=${1##$HERE/}
  local rec=$HERE/received/$N.txt && local exp=$HERE/expected/$N.txt
  local ok=1
  [ ! -f $rec ] && not_found $file received/$N.txt && ok=0
  [ ! -f $exp ] && not_found $file expected/$N.txt && ok=0

  # either received/expected not found
  if [ $ok = 0 ]; then
    [ $SILENT ] && return 1
    [ -f $rec ] && cat $rec
    return 1
  fi

  # gather stats and diff
  local DIFF=$(diff $rec $exp)
  if [[ -z $DIFF ]]; then
    pass $file "$title"
  else
    fail $file "$title"
    if [[ $SILENT != 'true' ]]; then
      echo "<: received, >: expected"
      echo "$DIFF"
    fi
  fi
  [ $VERBOSE ] && cat $rec
  [[ -z $DIFF ]] && return 0 || return 1
}

main() {
  # build
  cargo build --quiet || exit 1

  # ensure correct binary is used
  if ! command -v gitnu >/dev/null; then
    echo 'gitnu not found. Aborting.'
  fi

  # run tests
  if [ $ONE_TEST ]; then
    # run one test
    test $HERE/tests/$ONE_TEST.sh
  else
    # run all tests
    pids=()
    for t in $HERE/tests/*; do
      let TOTAL++
      assert $PWD $HERE
      N=$(get_test_id $t)
      tmp_dir=$HERE/tmp/$N && mkdir -p $tmp_dir
      cd $tmp_dir && test "$t" &
      pids+=("$!")
    done
    # wait for all tests to finish
    for pid in ${pids[@]}; do
      wait $pid
      [[ $? == 0 ]] && let PASSES++
    done
  fi

  # summarize
  printf "\n $PASSES/$TOTAL tests passed\n"
  [ $PASSES = $TOTAL ] && [ $TOTAL -gt 0 ] && exit 0 || exit 1
}

main
