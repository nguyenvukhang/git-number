#!/usr/bin/env bash

REPO="$HOME/repos/git-number/tests/repo"
# REPO="$HOME/repos/git-number/tests/repo/some/thing/is/up"
# REPO="$HOME/repos/uni/master/tex"
GIT_DIR=$(git rev-parse --git-dir)
[ -z $GIT_DIR ] && exit 0
CACHE_FILE=$GIT_DIR/gitn.txt
CACHE_DATA=("")

_N='\033[0m'    # Normal/Reset
_R='\033[0;31m' # Red
_G='\033[0;32m' # Green
_Y='\033[0;33m' # Yellow
_B='\033[0;34m' # Blue
_P='\033[0;35m' # Purple
_C='\033[0;36m' # Cyan
_S='\033[0;37m' # Gray

tab=$(printf '\t')
mode="" # 'staged' | 'unstaged' | 'untracked'

# gets the filename from one line in git status
get_filename() {
  [ -z "$1" ] && return 0
  local line=$1
  # remove the first tab
  line=${line/$tab}
  # trim off git-related keywords
  [[ $line == "deleted:"* ]] && line=${line#*deleted:}
  [[ $line == "modified:"* ]] && line=${line#*modified:}
  [[ $line == "new file:"* ]] && line=${line#*new file:}
  if [[ $line == "renamed:"* ]]; then
    line=${line#*renamed:}
    line=${line#* -> }
  fi
  # trim whitespace at the front
  filename="${line#"${line%%[![:space:]]*}"}"
  echo "$filename"
}

# prints enumerated git status to terminal
# updates the cache file
gitn_status() {
  # calls git status in the system
  local git_status=()
  while IFS= read -r line; do
    git_status+=("$line")
  done < <(git -c status.color=always status)

  local numbered_output=()
  local index=1
  # read git status line by line
  for line in "${git_status[@]}"; do
    local first_char=${line:0:1}
    # assumption: lines starting with tabs will contain a filename
    # that has to be enumerated
    if [[ $first_char == "$tab" ]]; then
      # print enumerated line
      echo "$index$line"
      # de-colorize the line
      : "${line//[m/}" # remove color resets
      : "${_//[31m/}" # remove reds
      : "${_//[32m/}" # remove greens
      local filename=$(get_filename "$_")
      numbered_output+=("$index $mode $PWD/$filename")
      (( index++ ))
      continue
    fi
    [[ $line == "Changes to be committed:" ]] && mode="staged"
    [[ $line == "Changes not staged for commit:" ]] && mode="unstaged"
    [[ $line == "Untracked files:" ]] && mode="untracked"
    # print original line from git status output
    echo "$line"
  done
  # write numbers to a cache file
  printf "%s\n" "${numbered_output[@]}" > $CACHE_FILE
}

get_cache_data() {
  while IFS= read line; do
    CACHE_DATA+=("${line#* }")
  done <"$CACHE_FILE"
}

gitn_add() {
  get_cache_data
  for number in ${NUMBERS[@]}; do
    local file="${CACHE_DATA[$number]}"
    echo "git add $file"
    [ $file ] && git add $file
  done
}

gitn_diff() {
  get_cache_data
  local number=${NUMBERS[1]}
  local file="${CACHE_DATA[$number]}"
  # if first argument after "diff" is an indexed number,
  # then run git diff on it
  # if not, pass all arguments through to vanilla git diff
  if [ $file ]; then
    git diff $file
    return 0
  fi
  printf "${_Y}git diff bypassed with args: ${NUMBERS[@]}${_N}\n"
  git diff ${NUMBERS[@]}
}

open_cache() {
  $EDITOR $CACHE_FILE
}

handle_arguments() {
  POSITIONAL_ARGS=()
  while [[ $# -gt 0 ]]; do
    case $1 in
      # handle flags here (see ags/ags)
      *)
        POSITIONAL_ARGS+=("$1"); shift;;
    esac
  done

  if [[ ${#POSITIONAL_ARGS[@]} -ne 0 ]]; then
    COMMAND="${POSITIONAL_ARGS[0]}"
    # remove command itself from positional arguments
    NUMBERS=("${POSITIONAL_ARGS[@]/$COMMAND}")
    [[ $COMMAND == "status" ]] && gitn_status
    [[ $COMMAND == "diff" ]] && gitn_diff
    [[ $COMMAND == "add" ]] && gitn_add
    [[ $COMMAND == "cache" ]] && open_cache
    return 0
  fi
  gitn_status
}

handle_arguments "$@"

# nvim -c "set ts=8" file.txt
