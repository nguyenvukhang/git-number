#!/usr/bin/env python3

import subprocess
import pprint
import json
import sys
from data_structure import *
from git_utils import git
from shell import system

pp = pprint.PrettyPrinter(indent=4).pprint


class bcolors:
    PURPLE = "\033[95m"
    BLUE = "\033[94m"
    CYAN = "\033[96m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    RED = "\033[91m"
    ENDC = "\033[0m"
    BOLD = "\033[1m"
    UNDERLINE = "\033[4m"


def stringify(color):
    def fn(*args):
        text = " ".join(args)
        print(color + text + bcolors.ENDC)

    return fn


class log:
    red = stringify(bcolors.RED)
    yellow = stringify(bcolors.YELLOW)
    green = stringify(bcolors.GREEN)
    blue = stringify(bcolors.BLUE)
    cyan = stringify(bcolors.CYAN)
    purple = stringify(bcolors.PURPLE)


ansi = ["\x1b[32m", "\x1b[31m", "\x1b[m"]


def print_and_extract_git_status(args: list[str], checkpoints: list[str]):
    result = []
    cmd = ["git", "-c", "status.color=always", "status"]
    cmd.extend(args)
    process = subprocess.Popen(
        cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        universal_newlines=True,
    )
    if not process.stdout:
        return
    index = 1
    counting = False
    while process.stdout.readable():
        line = process.stdout.readline()
        if not line:
            break
        stripped = line.strip()
        for i in ansi:
            stripped = stripped.replace(i, "")
        result.append((index, stripped))
        if counting:
            if stripped == "":
                counting = False
                print(line, end="")
            elif stripped in checkpoints:
                print(line, end="")
            else:
                print(index, line, end="")
                index += 1
        else:
            if stripped in checkpoints:
                counting = True
            print(line, end="")
    return result


def get_cache_filepath() -> str:
    cache_directory = system(["git", "rev-parse", "--git-dir"])
    return "%s/gitn.json" % (cache_directory)


def update_cache(cache_filepath: str, table: dict):
    with open(cache_filepath, "w") as f:
        json.dump(table, f)


# read from existing cache (do a full git bypass if there's no cache)
def gitn_add(args):
    # handles ranges in gitn add
    # gitn add 2-5 === gitn add 2 3 4 5
    add_range, rm_range = [], []
    for arg in args:
        if "-" in arg:
            try:
                split = list(map(int, arg.split("-")))
            except:
                continue
            if len(split) != 2 and not all(isinstance(x, int) for x in split):
                continue
            rm_range.append(arg)
            add_range.extend(map(str, range(split[0], split[1] + 1)))
    for i in rm_range:
        args.remove(i)
    args.extend(add_range)
    # read existing cache
    git_command = ["git", "add", "--"]
    table = {}
    try:
        with open(get_cache_filepath(), "r") as f:
            table = json.load(f)
        add_list = list(
            map(lambda x: get_filename(table.get(x, make_empty_entry())), args)
        )
        git_command.extend(add_list)
    except:
        git_command.extend(args)
    git_command = list(filter(None, git_command))
    # subprocess.run(git_command)


def retrieve_table() -> tuple[bool, dict]:
    table = {}
    status = True
    try:
        with open(get_cache_filepath(), "r") as f:
            table = json.load(f)
    except:
        status = False
    return (status, table)


# print and extract git status
# enumerate git status
# update cache
def gitn_status(args):
    print("gitn status args:", args)
    git_status = print_and_extract_git_status(args, git.set_state_keys)
    if not git_status:
        return
    table = create_table(git_status)
    update_cache(get_cache_filepath(), table)


def expand_ranges(args: list[str]) -> list[str]:
    result = []
    if len(args) == 0:
        return []
    for arg in args:
        # straight bypass for certain keywords
        if arg in git.commands:
            result.append(arg)
            continue
        # handle number ranges
        if "-" in arg:
            try:
                split = list(map(int, arg.split("-")))
            except:
                result.append(arg)
                continue
            if len(split) != 2 and not all(isinstance(x, int) for x in split):
                result.append(arg)
                continue
            result.extend(map(str, range(split[0], split[1] + 1)))
        # bypass for the rest
        else:
            result.append(arg)
    return result


def get_git_command(args: list[str]) -> tuple[str, int]:
    for i in range(len(args)):
        word = args[i]
        if word in git.commands:
            return (word, i)
    return ("", 0)


# processes arguments, and returns the list of processed args
def handle_arguments(args: list[str]) -> list[str]:
    num_args = len(args)
    command, command_index = get_git_command(args)
    if num_args <= 1 or command == "status":
        gitn_status(args[command_index + 1 :])
        return args
    # from here on there are at least two args
    # if gitn command doesn't include status
    # it's essentially a full bypass with the numbers as file aliases
    args[0] = "git"
    args[1:] = expand_ranges(args[1:])
    table_exists, table = retrieve_table()
    if table_exists:
        return args
        # do the mapping
    else:
        return args
        # do a full bypass


def expect(tested, correct):
    if tested == correct:
        log.green("ok", *tested)
    else:
        log.red(*tested)
        log.green(*correct)


def debug(args: list[str]) -> list[str]:
    which = system(["which", "gitn"])
    gitn = args[0]
    if len(args) == 2 and args[1] == "--test":

        def test(x):
            print(x)
            return handle_arguments([gitn] + x.split(" ")[1:])

        # run test suite
        log.purple('\nwrite to cache')
        expect(test("gitn status"), [which, "status"])
        expect(test("gitn status some/thing"), [which, "status", "some/thing"])
        log.purple('\nread from cache')
        expect(test("gitn add 1 2 3"), ["git", "add", "1", "2", "3"])
        expect(test("gitn add 1 2 4-7"), ["git", "add", "1", "2", "4", "5", "6", "7"])
        expect(test("gitn add 1-1 4-7"), ["git", "add", "1", "4", "5", "6", "7"])
        pass
    # full bypass
    return args


def main():
    args = debug(sys.argv)
    handle_arguments(args)


if __name__ == "__main__":
    main()
