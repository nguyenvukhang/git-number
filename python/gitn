#!/usr/bin/env python3

import sys
from data_structure import *
from _git import git
from strings import sanitize
from shell import system_std
from tests import debug
import cache
from log import log
import subprocess

ansi = ["\x1b[32m", "\x1b[31m", "\x1b[m"]

def print_and_extract_git_status(args: list[str], checkpoints: list[str]):
    cmd = git.cmd.status
    cmd.extend(args)
    stdout, stderr = system_std(cmd)

    stderr_lines = stderr.readlines()
    if len(stderr_lines) > 0:
        for line in stderr_lines:
            print(line.strip())
        return

    if not stdout:
        return

    result, index, counting = [], 1, False

    stdout_lines = stdout.readlines()

    if len(stdout_lines) == 0:
        return

    for line in stdout_lines:
        stripped = sanitize(line)
        result.append((index, stripped))
        if counting:
            if stripped == "":
                counting = False
                print(line, end="")
            elif stripped in checkpoints:
                print(line, end="")
            else:
                print(index, line, end="")
                index += 1
        else:
            if stripped in checkpoints:
                counting = True
            print(line, end="")
    return result


# print and extract git status
# enumerate git status
# update cache
def gitn_status(args):
    git_status = print_and_extract_git_status(args, git.set_state_keys)
    if not git_status:
        return
    table = create_table(git_status)
    cache.update(cache.get_filepath(), table)


def expand_ranges(args: list[str]) -> list[str]:
    result = []
    if len(args) == 0:
        return []
    for arg in args:
        # straight bypass for certain keywords
        if arg in git.commands:
            result.append(arg)
            continue
        # handle number ranges
        if "-" in arg:
            try:
                split = list(map(int, arg.split("-")))
            except:
                result.append(arg)
                continue
            if len(split) != 2 and not all(isinstance(x, int) for x in split):
                result.append(arg)
                continue
            result.extend(map(str, range(split[0], split[1] + 1)))
        # bypass for the rest
        else:
            result.append(arg)
    return result


# processes arguments, and returns the list of processed args
def handle_arguments(args: list[str]) -> list[str]:
    # log.yellow('\nhandle args @', os.getcwd())
    num_args = len(args)
    command, command_index = git.get_commmand(args)
    if num_args <= 1 or command == "status":
        gitn_status(args[command_index + 1 :])
        return args
    # from here on there are at least two args
    # if gitn command doesn't include status
    # it's essentially a full bypass with the numbers as file aliases
    trailing = expand_ranges(args[command_index + 1 :])
    command_list = args[: command_index + 1]
    command_list[0] = "git"
    table_exists, table = cache.get_table()
    if table_exists:

        def get_filename_from_table(x) -> str:
            s = x
            if x.isdigit():
                s = ''
            elem = table.get(x, make_entry("", "", s))
            return get_filename(elem)

        trailing = list(filter(None, map(get_filename_from_table, trailing)))
        cmd = command_list + trailing
        log.gray(*cmd)
        subprocess.run(cmd)

        return args
        # do the mapping
    else:
        return args
        # do a full bypass


def main():
    args = debug(sys.argv, handle_arguments)
    handle_arguments(args)


if __name__ == "__main__":
    main()
