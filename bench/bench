#!/usr/bin/env python3

import os
import tempfile
from collections import deque
import subprocess
import shutil
import threading
import time
import math


filenames = []
threads = deque([])
results = []  # used for paired runs with git
timings = []  # used for solo runs
is_locked = False
gitnu = os.getenv("GITNU_RELEASE_BIN") or "gitnu"


def sh(cmd, cwd=None):
    subprocess.run(cmd, cwd=cwd, capture_output=True)


def bench_dir():
    return os.path.dirname(os.path.realpath(__file__))


def get_filenames():
    with open(os.path.join(bench_dir(), "filenames.txt")) as f:
        for line in f:
            filenames.append(line.strip())


def file(i):
    return filenames[i]


class Result:
    def __init__(self, gitnu, git, std_dev=0.0):
        self.gitnu = gitnu
        self.git = git
        self.std_dev = std_dev

    def __str__(self):
        diff = self.gitnu - self.git
        percent = 1 if self.git == 0 else self.gitnu / self.git
        std_dev = self.std_dev
        if self.std_dev > 0:
            return "+%.10fs,\n%.4f × of git time\nratio std.dev %.10f" % (
                diff,
                percent,
                std_dev,
            )
        else:
            return "+%.10fs,\n%.4f × of git time" % (diff, percent)

    def __repr__(self):
        return self.__str__()


class Test:
    def __init__(self, file_count):
        self.dir = tempfile.TemporaryDirectory()
        os.chdir(self.dir.name)
        sh(["git", "init"])
        file_cmd = ["touch"]
        for i in range(file_count):
            file_cmd.append(file(i))
        sh(file_cmd)

    def commands(self, commands):
        for cmd in commands:
            sh(cmd)

    def run(self):
        _gitnu = self.time_status(gitnu)
        _git = self.time_status("git")
        if _gitnu is not None and _git is not None:
            timings.append(_gitnu)
            add_result(Result(_gitnu, _git))

    # create a whole fresh directory and run the bench there
    # this is because git does a bunch of caching that speeds
    # up the second run in the same directory
    def time_status(self, bin):
        run_dir = tempfile.TemporaryDirectory()
        repo = os.path.join(run_dir.name, os.path.basename(bin))
        try:
            shutil.copytree(self.dir.name, repo)
        except:
            return None
        start = time.time()
        sh([bin, "status"])
        end = time.time()
        run_dir.cleanup()
        return end - start

    def cleanup(self):
        self.dir.cleanup()


def add_result(r):
    global is_locked
    if is_locked:
        time.sleep(0.0001)
        add_result(r)
        return
    else:
        is_locked = True
        results.append(r)
        is_locked = False


def fork(f):
    t = threading.Thread(target=f, args=())
    t.start()
    threads.append(t)


def test(n=10):
    test = Test(n)
    test.run()
    test.cleanup()


def average(lst):
    n = len(lst)
    return 0.0 if n == 0 else sum(lst) / n


def analyze(results):
    total_gitnu, total_git, n = 0, 0, len(results)
    # gitnu:git execution time
    ratios = []
    for r in results:
        total_git += r.git
        total_gitnu += r.gitnu
        ratios.append(r.gitnu / r.git)

    avg_ratio = average(ratios)
    squared_dst = map(lambda x: (avg_ratio - x) ** 2, ratios)
    # sample standard deviation of ratios
    std_dev = math.sqrt(sum(squared_dst) / (n - 1))
    return Result(total_gitnu, total_git, std_dev)


def bench(iterations=2):
    results = []
    for i in range(iterations):
        print("test %d" % i)
        test = Test(1000)
        test.run()
    return analyze(results)


def parallel_bench(iter=5, max_parallel=4, interval=0.01, fn=lambda x: x):
    for i in range(iter):
        time.sleep(interval)
        print("[%d] threads running:" % i, len(threads))
        if len(threads) >= max_parallel:
            t = threads.popleft()
            t.join()
        fork(lambda: test(fn(i)))
    while len(threads) > 0:
        print("remaining: %d" % len(threads))
        time.sleep(0.02)
        t = threads.popleft()
        t.join()
    return analyze(results)


def std_dev(lst):
    n = len(lst)
    if n < 2:
        return 0
    mean = average(lst)
    squared_dst = map(lambda x: (mean - x) ** 2, lst)
    return math.sqrt(sum(squared_dst) / (n - 1))


def main():
    iterations = 30
    parallel = True
    threads = 4
    interval = 0.01
    results = (
        parallel_bench(iterations, threads, interval, fn=lambda x: x**2)
        if parallel
        else bench(iterations)
    )
    print("-----")
    print(results)
    print("-----")
    print("averge runtime: ", average(timings))
    print("runtime std.dev:", std_dev(timings))


if __name__ == "__main__":
    get_filenames()
    main()
